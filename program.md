Память для программы в нашем случае ограничена 850 байтами. Память данных 150 байтами.

Проверить сколько занято можно командой `info`. Попробуем написать часть кода немного экономнее - заодно и вводить меньше.

Наша программа должна по сути состоять из 3х частей:

- настройка и инициализация данных
- получение измерения с датчика
- отображение на индикатор

В инициализации нам надо заполнить массив для индикатора.  
Мможно сгруппировать записи для 2 цифр в одну строку (и сэкономим на 5 словах "data"):

    5 dim n 70 b
    10 data 0 0 0 1 0 0 0  1 1 0 1 1 0 1 
    12 data 0 0 1 0 1 0 0  1 0 0 0 1 0 0 
    14 data 1 1 0 0 0 0 1  1 0 0 0 0 1 0 
    16 data 0 0 0 0 0 1 0  1 1 0 1 1 0 0
    18 data 0 0 0 0 0 0 0  1 0 0 0 0 0 0

Заведем еще массив для хранения двух цифр, выводимых на индикатор (вместо двух переменных `a1` и `a2`):

    20 dim d 2 b

Далее, сам код предлагается вынести в две подпрограммы. Вызывать их будем командами `gosub`.
Измерения пусть делаются в одной подпрограмме, с адресом, скажем, `100` и оставляют значение
в переменной например `t`. А вторая подпрограмма, с адресом, скажем, `500` пусть выводит
на индикатор из массива `d`.
    
    30 gosub 100
    35 d(0)=t/10
    36 d(1)=t%10
    40 gosub 500
    50 goto 30

Такой подход позволит нам немного удобнее отлаживать код.
Например можно будет вызов одной из подпрограмм можно временно удалить,
а числа для проверки записать константные и т.п. Или, к примеру - думаю, это будет актуально - можно будет
вывод на индикатор повторить сколько-то раз, это поможет сделать небольшую задержку между измерениями, чтобы
цифры не изменялись слишком часто если показание датчика колеблется...

Подпрограмма для измерений будет наверняка довольно короткая. Главное - записать какое-то значение в переменную T
и осуществить команду `return` для возврата из подпрограммы:

    100 t=adc(0)
    105 t=t-500
    110 t=t/4
    120 return

Конечно формулы в строках 100...110 возможно надо подправить, они очень приблизительные. Пробелы вокруг знаков равенства
и математических операторов можно не ставить (каждый пробел экономит один байт, хехе).

А вообще эту подпрограмму можно добавить когда будет отлажено все остальное. А для начала просто заменить строки 30, 35, 36
на что-то вроде `35 d(0)=3` и `36 d(1)=6` для проверки кода индикатора.

Теперь перейдем к подпрограмме вывода числа на индикатор. Код для вывода на обе цифры в общем-то одинаков, поэтому сделаем
цикл по номеру цифры, а номер этот будет изменяться от `0` до `1` включительно (пусть он хранится в переменной `p`):

    500 p=0
    510 rem here'll be code for display
    600 p=p+1
    610 if p<2; goto 510
    620 return

Эту подпрограмму мы также завершим командой `return`. Теперь осталось только написать код вместо 510 строки, в которой
временно поселился комментарий.

    510 i = 0
    515 delay 5
    520 pin 9; 1-p
    530 x = d(p)*7+i
    540 pin i+2; n(x)
    550 i=i+1 
    560 if i<7; goto 515 

Пожалуй и все (по сравнению с начальной версией мы только перетащили условие в конец цикла, чтобы не писать два `goto` в
разных местах).

Кроме того обратим внимание на строку 520 - здесь мы в 9-й пин выводим значение зависящее от `p` - от того, какую цифру,
первую или вторую надо отобразить.

P.S. Упоминалось, что выдачу одного и того же измерения на индикатор может быть есть смысл повторить несколько раз. Ведь
сейчас у нас обе цифры отображаются в течение где-то 10 миллисекунд. Можно повторить вызов этой подпрограммы, скажем, 30 раз.

Для этого немного дополним основной код в районе строки 40:

    39 m=30
    40 gosub 500
    42 m=m-1
    43 if m>0; goto 40
